#### JAVA

##### 锁

> 1、乐观锁VS悲观锁：悲观锁是认为会有其他线程访问，所以需要加锁(synchronized、lock);乐观锁，不认为有其他线程访问，CAS(其实就是无锁)
>
> 2、自旋锁：线程不阻塞，避免操作系统切换cpu。CAS，一直while循环自选，默认10。自适应自旋，根据前一次在锁上的自旋时间决定
>
> 3、公平锁、非公平锁：公平锁根据线程申请锁的顺序获取锁。非公平锁是释放锁时，如果有线程正好获取锁，直接获取成功。都不需要唤醒等待的线程ReentrantLock,底层基于AQS(标识加锁值(锁了多少次)、当前线程id、排队队列)
>
> 4、无锁、偏向锁、轻量级锁、重量级锁：是针对synchronized。存在对象头
>
> 5、可重入、非可重入锁：ReentrantLock、synchronized是可重入锁
>
> 6、独享锁、共享锁：也是基于AQS，有一个写锁和读锁。拆分state标识2个锁的锁个数。有读锁时不能申请写锁，有写锁时读锁阻塞。

##### 线程池



####  数据库

##### Mysql：单机1000QPS

核心原理：

1、mysql数据结构

> 1、采用B+树结构：非叶子结点不存储data，只存储指针。叶子结点只存储data；每个叶子结点有指向相邻叶子结点的指针

2、索引

> 1、主键索引、非主键索引。主键索引保存数据，非主键索引保存主键值
>
> 2、回表：就是使用非主键索引查询到主键后，再去主键索引上查询数据
>
> 3、查询优化：覆盖索引(查询的值再非主键索引上，即不需要回表)；最左索引(索引是排序好的，可以使用like'xx%')；索引下推，可以对索引上的字段进行过滤(需要保证是=值查询)，减少回表次数

3、事务

> 读未提交：事务没提交变更也能被看到(别人改的数据，没提交事务我也能看到)
>
> 读提交：事务提交后的变更才能被看到(别人改的数据事务提交后我才能看到)
>
> 可重复读：事务执行过程中看到的数据和事务开启时数据一直(mysql使用MVCC实现)
>
> 串行化：读写都加锁

4、MVCC 多版本并发控制

> 事务隔离的一种实现。用来实现提交读和可重复读
>
> 原理：数据库有隐藏的2列(创建版本号、删除版本号)。每个事务会创建read-view，有对应的undo log（回滚日志）。可重复读事务获取值时，先获取当前值，再根据read-view和事务id回滚对应的事务

5、锁

> 表锁：
>
> 行锁：原理是在索引上加锁(主键索引直接加，非主键索引加非索引和对应的主键索引)
>
> next-key lock(间隙锁+行锁)：在update、delete时在mysql索引扫描过的记录，和相邻的键值(在可重复读级别解决幻读问题)。本质是锁住B+树的左右索引指针，保证前后不能插入数据

##### Redis ：单机10wQPS

核心原理

1、redis的单线程模型

> 1、使用文件事件处理器(包括：多个套接字，IO多路复用、文件事件分派器、事件处理器)，因为文件事件分派器是单线程的，所以redis是单线程的
>
> 2、redis6.0使用多线程：请求接收和解析，以及处理后通过网络返回是使用多线程。命令请求的数据读写还是单线程

2、redis过期删除策略

>a、redisDb数据中，存在一个expires的map，用于存放设置过期时间的key
>
>b、过期策略：惰性删除（访问时先判断是否过期，过期则删除）;redis周期获取一定过期的随机key进行检查，删除
>
>c、从库不会删除过期key，主库删除时同步给从库删除命令。过期期间从库读取(3.2前返回值，3.2从库判断是否过期，过期不返回，但是不删除)

3、redis持久化

> 1、2种持久化方式：RDB(快照-fork子进程把全量数据保存到文件);AOF(记录写命令，追加到AOF末尾。时间长后需要重写--主线程fork子进程，内存也拷贝，读取内存成命令写AOF，过程中的命令会写2份(原来的AOF、重新的AOF))
>
> 2、RDB适合做冷备,恢复时间快

4、redis内存淘汰机制

> 默认不淘汰，内存不足时报错
>
> volatile前缀是对于设置过期时间的key
>
> allkeys对于所有key
>
> 常用：xxx-LRU(lateset recently used)最近使用；LFU(latest Frequently used)：最不常用；随机；ttl(即将过期)

5、redis分布式部署方式

> 2种方式：保证高可用的redis哨兵模式(sentinel)--主从;扩展存储的cluster模式，使用cluster分片存储，每个分片分配多个hash槽来存储key--去中心

常见问题：

1、缓存雪崩、击穿、穿透

> 雪崩：大量的key设置了相同的过期时间，缓存失效，导致大量请求顺时DB压力增大--过期时间加上随机值；设置熔断防止db挂掉
>
> 击穿：一个热点key，失效后对db造成压力--查询db时设置互斥锁(setnx)
>
> 穿透：访问不存在的key，请求会穿透到DB，对DB造成压力--

#### 中间件

##### Zookeeper



