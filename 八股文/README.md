#### JAVA

##### JVM

> 组成：类加载器、运行期数据区、执行引擎

> 运行期数据组成：程序计数器、栈、堆、方法区
>
> 程序计数器：表示某个线程执行代码位置
>
> 栈：存放线程执行的方法(指向运行时常量池的引用)，和方法内的局部变量
>
> 堆：存放对象
>
> 方法区：JVM加载class信息、静态变量、常量

##### JVM垃圾回收

###### 垃圾对象标记算法

> 引用计数法：对象有引用+1，引用为0的可以回收
>
> 可达性分析：从GCROOT出发，对引用的对象进行标记
>
> GCROOT：线程栈中的变量、方法区静态属性、方法区常量、JNI引用对象

###### 回收算法

> 清理1、标记清除算法：标记、清除(不会真正清理，只是记录在可用空间表里)
>
> 压缩2、标记整理：标记、整理(移动所有存活对象)，按内存地址依次排序，最后将末端后的内存回收
>
> 复制：将内存分为对象和空闲2部分，对象部分用完后吧存货的复制到空闲的区域

###### 垃圾收集器

新生代：Serial(串行)；ParNew、Parallel Scanvenge 都是复制算法

老年代：Serial(标记整理)、Parallel(标记整理)、CMS(标记清除)

G1:适用于新生代和老年代(复制+标记整理)

CMS：是为了影响用户时间最短，回收的某个阶段可以用户线程和回收线程并行

##### 锁

> 1、乐观锁VS悲观锁：悲观锁是认为会有其他线程访问，所以需要加锁(synchronized、lock);乐观锁，不认为有其他线程访问，CAS(其实就是无锁)
>
> 2、自旋锁：线程不阻塞，避免操作系统切换cpu。CAS，一直while循环自选，默认10。自适应自旋，根据前一次在锁上的自旋时间决定
>
> 3、公平锁、非公平锁：公平锁根据线程申请锁的顺序获取锁。非公平锁是释放锁时，如果有线程正好获取锁，直接获取成功。都不需要唤醒等待的线程ReentrantLock,底层基于AQS(标识加锁值(锁了多少次)、当前线程id、排队队列)
>
> 4、无锁、偏向锁、轻量级锁、重量级锁：是针对synchronized。存在对象头
>
> 5、可重入、非可重入锁：ReentrantLock、synchronized是可重入锁
>
> 6、独享锁、共享锁：也是基于AQS，有一个写锁和读锁。拆分state标识2个锁的锁个数。有读锁时不能申请写锁，有写锁时读锁阻塞。

##### 线程池



####  数据库

##### Mysql：单机1000QPS

核心原理：

1、mysql数据结构

> 1、采用B+树结构：非叶子结点不存储data，只存储指针。叶子结点只存储data；每个叶子结点有指向相邻叶子结点的指针

2、索引

> 1、主键索引、非主键索引。主键索引保存数据，非主键索引保存主键值
>
> 2、回表：就是使用非主键索引查询到主键后，再去主键索引上查询数据
>
> 3、查询优化：覆盖索引(查询的值再非主键索引上，即不需要回表)；最左索引(索引是排序好的，可以使用like'xx%')；索引下推，可以对索引上的字段进行过滤(需要保证是=值查询)，减少回表次数

3、事务

> 读未提交：事务没提交变更也能被看到(别人改的数据，没提交事务我也能看到)
>
> 读提交：事务提交后的变更才能被看到(别人改的数据事务提交后我才能看到)
>
> 可重复读：事务执行过程中看到的数据和事务开启时数据一直(mysql使用MVCC实现)
>
> 串行化：读写都加锁

4、MVCC 多版本并发控制

> 事务隔离的一种实现。用来实现提交读和可重复读
>
> 原理：数据库有隐藏的2列(创建版本号、删除版本号)。每个事务会创建read-view，有对应的undo log（回滚日志）。可重复读事务获取值时，先获取当前值，再根据read-view和事务id回滚对应的事务

5、锁

> 表锁：
>
> 行锁：原理是在索引上加锁(主键索引直接加，非主键索引加非索引和对应的主键索引)
>
> next-key lock(间隙锁+行锁)：在update、delete时在mysql索引扫描过的记录，和相邻的键值(在可重复读级别解决幻读问题)。本质是锁住B+树的左右索引指针，保证前后不能插入数据

6、日志

> binlog：mysql的server层。归档日志。可以用来恢复数据
>
> redo log：InnoDB的日志。数据更新时先写日志，等周期或者日志满再刷到磁盘，提供了crash-safe能力。即WAL(write-ahead loggin,预写日志)。其实是为了Buffer Pool问题引入的(InnoDB为了提升效率，把部分数据也映射，作为数据库的缓冲，会先写Buffer Pool，定期刷新到磁盘)
>
> undo Log：回滚日志。记录事务的回滚日志。是事务的原子性和隔离性的实现基础



常见问题：

1、InnoDB数据的一致性

根据binlog 和redolog的2阶段提交：prepare、写binlog、commit。宕机后根据2个日志的状态可以进行对应的回滚

2、主从数据不一致

> 1、强制读主
>
> 2、缓存需要读取主库的数据key，并根据主从同步时延设置超时时间

3、数据库和缓存的一致性

> 1、先更新数据库，后删除缓存
>
> 2、主从模式，缓存不一致：可以使用cacel订阅从库的binlog来删除缓存

4、索引失效场景

> 1、不使用不等于(!= <>)
>
> 2、不进行null判断(is null,is not null)
>
> 3、in、not in
>
> 4、like 没有最左前缀
>
> 5、where字段使用函数操作
>
> 6、使用or连接了没有索引的字段

##### Redis ：单机10wQPS

核心原理

1、redis的单线程模型

> 1、使用文件事件处理器(包括：多个套接字，IO多路复用、文件事件分派器、事件处理器)，因为文件事件分派器是单线程的，所以redis是单线程的
>
> 2、redis6.0使用多线程：请求接收和解析，以及处理后通过网络返回是使用多线程。命令请求的数据读写还是单线程

2、redis过期删除策略

>a、redisDb数据中，存在一个expires的map，用于存放设置过期时间的key
>
>b、过期策略：惰性删除（访问时先判断是否过期，过期则删除）;redis周期获取一定过期的随机key进行检查，删除
>
>c、从库不会删除过期key，主库删除时同步给从库删除命令。过期期间从库读取(3.2前返回值，3.2从库判断是否过期，过期不返回，但是不删除)

3、redis持久化

> 1、2种持久化方式：RDB(快照-fork子进程把全量数据保存到文件);AOF(记录写命令，追加到AOF末尾。时间长后需要重写--主线程fork子进程，内存也拷贝，读取内存成命令写AOF，过程中的命令会写2份(原来的AOF、重新的AOF))
>
> 2、RDB适合做冷备,恢复时间快

4、redis内存淘汰机制

> 默认不淘汰，内存不足时报错
>
> volatile前缀是对于设置过期时间的key
>
> allkeys对于所有key
>
> 常用：xxx-LRU(lateset recently used)最近使用；LFU(latest Frequently used)：最不常用；随机；ttl(即将过期)

5、redis分布式部署方式

> 3种方式：简单主从模式(master宕机手动切换)，保证高可用的redis哨兵模式(sentinel)--主从;扩展存储的cluster模式，使用cluster分片存储，每个分片分配多个hash槽来存储key--去中心
>
> 主从同步方式：
>
> a、从库启动时，主库通过bgsave生成RDB同步给从库，同时把repl_backlog_buffer(一个环形缓冲区)数据给从库
>
> b、从库同步完文件后，通过replication_buffer中的offset同步repl_backlog_buffer中的内容
>
> c、建立长链接开始常规的命令复制
>
> d、长链接断开的话，根据replication_buffer中的offset同步repl_backlog_buffer



常见问题：

1、缓存雪崩、击穿、穿透

> 雪崩：大量的key设置了相同的过期时间，缓存失效，导致大量请求顺时DB压力增大--过期时间加上随机值；设置熔断防止db挂掉
>
> 击穿：一个热点key，失效后对db造成压力--查询db时设置互斥锁(setnx)
>
> 穿透：访问不存在的key，请求会穿透到DB，对DB造成压力--接口层添加校验(过滤不合理的参数)；空值写进缓存添加较短的过期时间；布隆过滤器，不存在的key直接过滤

2、redis分布式锁

三要素：安全(互斥)，死锁释放，故障容错

> 互斥：使用原子的操作设置
>
> 死锁释放：设置超时时间、自动续期；删除时先判断再删除
>
> 故障容错：RedLock方案：添加锁需要n/2+1个节点设置成功。删除锁发送给所有节点

3、分布式锁遇到主从同步

redis是AP不是CP，所以会存在问题

> RedLock方案：使用多个master记录锁，删除锁给所有节点发送
>
> 如果对锁特别敏感建议使用ZK，保证强一致性

#### 中间件

##### Zookeeper



#### 扩展

##### 布隆过滤器

一个很长的二进制向量和多个hash函数。key哈希后对应的向量位置设为1，当判断key是否存在是，hash后看对应位置是否都为2。

返回结果：一定不存在、可能存在(因为可能会误判)

##### master/slave和leader/follower

master/slave即为主从，一般用于数据库场景。master写，slave读

leader/follower其实是为高可用准备。follower只承担副本的作用，当leader宕机后在多个follower选举出leader