


### HBI

服务启动、rpc、注册中心、MQ、redis、定时任务、DB

#### 项目架构

1、使用Spring-clound+OpenFeign+Eureka

2、使用Nacos做动态配置服务

3、引入RabbitMQ做消息队列。用于原子表数据更新，合表和视图数据更新

4、引入Redis来缓存业务数据库，以及查询数据

5、数据库。90%数据来自Hive，走Spark查询。9%来自啊Doris，提高查询速度。TiDB用来保存实时表(为什么这么设计)

##### 数据存储

1、每个集团数据是隔离的:每个集团一个库，对应相同名称的表

2、用户查询时只能查询到自己集团和个人表的数据

#### 项目重要功能点的架构设计

所有任务都是用xxlJob来调起，这样方便失败重试

##### 原子表更新

> bi表对应一个大仓的Gauss表

//0 0/10 2-3 * * ?
每天2-3点开始同步大仓和私仓的分区

由于数仓不发送作业完成的mq。所以定时去xxlJob查询当天匹配规则的调度

检测到大仓表更新后，发送mq

收到MQ后添加xxljob，开始数据同步

同步时记录log，方便下游表使用

###### 怎么落盘

通过thriftServer操作数据库

1、先同步分区元数据

2、insert overwrite table来抽取数据

###### schema修改怎么办

不建议修改字段，修改后需要全量同步数据

可以添加字段，


##### 合表、物化设计

普通合表即创建视图，同时能够视图间依赖。目的简化sql

合表开启物化后，即把数据进行落盘

###### 什么时候落盘

1、平台上初始开启时

> 发送添加xxlJob任务

2、每天作业任务

> 上游表(原子或者合表)更新后，发送MQ
>
> 接收到MQ后添加xxlJob
>
> job中使用redis作为分布式锁(10s)。后面还有mysql状态来保证重复操作
>
> 检查依赖的所有表是否更新

###### 怎么分区

没有分区，因为物化表是自己写sql。可能没有分区字段


##### Doris加速

物化后开启高速功能，即吧数据抽取一份到Doris


- 怎么分区分桶

没有分区，使用时间字段进行了分桶

> 分桶只是吧数据打散，对查询没有任何加速

- 这样真的快了吗

> 分区分桶不合适，没有优化查询
>
> 优化就是使用了Doris的列式存储的优化和插叙优化


##### Sql引擎设计

- 怎么提供可扩展、逻辑清晰的sql引擎






##### 缓存设计

- 缓行队列有什么问题

- 重新设计。很普通，如何再优化



#### OpenFeign

基于Ribbon的一个.具有负载均衡功能的声明的REST服务(http)

本质是提供controller，走http请求进行servive通信

默认采用轮训的方式去负载均衡

> 注:如果只是提供http，服务申请域名了。那就走的是ngnix的负载均衡

#### Eureka

一个简单的注册中心,采用CS架构

分为Eureka Server、Service Provider、Service Consumer

server直接启动一个spring-clound程序，开启@EnableEurekaServer即可

client注册到server上。有health机制，同时提供api来手动下线client

使用方获取服务发现列表，再结合OpenFeign来达到 微服务之间调用，同时提供简单的负载均衡

- 优缺点






#### Nacos

- 原理

项目启动时会优先走nacos的配置，去拉取配置项

> 拉取到本地一个文件夹下

启动后根据注解进行赋值


#### RabbitMQ

- 原理


- 优缺点






#### Redis


- 原理

- Redis Cluster

- 快的原因

- 优缺点






#### Spark

- 原理





#### Doris

- 原理

- Rollup

- 数据模型






#### TiDB

- 原理

- 与分库的mysql相比性能如何



