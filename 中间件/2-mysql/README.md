### Mysql

mysql由server层和存储引擎组成

server层包括：连接器（管理链接、权限校验）、查询缓存、分析器（词法分析、语法分析）、优化器（执行计划生成，索引选择）、执行器（操作引擎返回结果）

DDL：Data Definition Language数据定于语言，即对表结构的修改操作

DML：Data Manipulation Language数据操控语言，即对表数据的修改

#### 索引

##### 索引数据结构

> mysql使用B+树
>
> B+树高度：innodb不能定义树的高度，或者m树的m值。mysql5.7可以指定page大小。默认是16k。
>
> 可以存储数据大小计算方式：主键id(bigint)8字节，指针6字节。一个共16*1024/14=1170个。数据大约1k一条，一页16行。2层数可以存储1170x16。3层1170x1170x16约2000w(20G多)。4层1170x1170x1170x16条(25.6T)

使用索引比较：

hash：一般用于等值查询

###### B树

每个节点存储关键字数组、指针数组（指向儿子）、数据

###### B+树

非叶子结点不存储data，叶子结点不存储指针

每个叶子结点增加指向相邻叶子结点的指针

##### 为什么使用B+数

1、适合磁盘存储，能够利用磁盘预读(一次加载一页，默认是16k)，加载更多的索引到内存

2、树高度低，能存储大量数据

3、支持范围查询、有序查询

##### 聚簇索引

一种数据存储方式。InnoDB主键使用聚簇索引：叶子结点上的data保存的是对应行的全部数据

优点：访问速度快，只要找到索引，立即能获取到数据

##### 非聚簇索引

也叫二次索引，保存的是主键的值

优点：减少IO次数

但是可能需要回表：即先查询到主键再查主键对应的数据

> MyISAM叶子节点存储的表的指针
>
> InnoDB叶子节点存储的数据行

##### 存储

GBK：单字符最大可占用2个字节。
UTF8：单字符最大可占用3个字节。
UTF8MB4：单字符最大占4个字节(可以存放emoji)

1、存储数据

可null列，对单独存放一个null标示

varchar由于是可变的，所以需要存放长度(根据声明的字符长度来计算：小于255使用1字节，大于255使用2字节)

2、存储索引

mysql5.6及其以前版本索引默认最大长度为767byte(使用utf-8正好是varchar(255))
5.7以后版本最大为3072byte

> Innodb引擎：单索引字段长度过长，索引会进行截取(相当于使用了前缀索引)。组合索引最大长度为 列数*单索引最大长度限制



##### 索引查询优化

1、最左前缀匹配原则

> mysql索引是排序好的，一直向右匹配直到遇到范围查询(>< between、like)
>
> 例：(a,b,c,d)索引使用a = 1 and b = 2 and c > 3 and d = 4查询只使用了abc索引

2、索引下推

> Mysql5.6添加，可以对联合索引上的前面字段筛选后，会下推到下个索引字段进行过滤(只过滤=)

3、覆盖索引

> 查询的数据在索引树上能查询到，不需要回表。比如联合索引

4、导入大量数据时，可以先删除索引，再重建(因为索引自平衡会导致写入变慢)

#### 锁

##### 表锁

1、表锁

> lock table ... read/write 会使用表锁

update t set colunm_1 += 1 where colunm_1 = xx

如果column_1没有索引,加表锁

2、原数据锁(MDL锁)

与java中的读写锁类似，保证DDL和DML操作的一致性

> insert、delete、select、delete 都会先获取MDL读锁

> 数据库表结构变更，先获取MDL写锁

MDL的申请会形成一个队列，写锁优先级高于读锁。一出现写锁，会阻塞后续的所有操作

##### 行级锁

行锁实现：InnoDB通过给索引上的索引项加锁实现的

> 主键索引，mysql会锁定主键索引
>
> 非主键索引，mysq会锁定非主键索引，再锁定主键索引
>
>若没有索引，则使用表锁

next-key lock(间隙锁和行锁合称):只出现在可重复度级别，为了解决幻读问题

> 在update、delete操作时，mysql锁定where扫描过的所有索引记录，还会锁定相邻的键值，即所谓的next-key
>
> 原因：B+树结构中，其实是锁住索引对应的左右索引指针，保证前后不能插入数据

##### 死锁

1、设置获取锁等待超时时间(不推荐)

2、开启死锁检测

> mysql发现死锁，则主动回滚其中的某一个事务

##### 其他锁

共享锁：lock in share mode	对结果每行加共享锁

排它锁：update、delete、insert、for update。其他事务不能对锁住的数据再加锁

意向锁：申请行锁时，先申请意向锁。表示我表中有一行在使用锁。当表锁来时，判断有意向锁，就等待

#### MVCC（多版本并发控制）

InnoDB实现隔离级别的一种实现。用来实现提交读和可重复读

数据中有隐藏的2列(数据对应的事务id、上个版本的roll_pointer):以前版本的数据是保存在undo log中的，版本数据使用类似链表的结构来指向

更新的数据的时候会记录一条回滚操作，当没有事务再需要这个read-view时删除

###### 可重复读事务隔离实现方式

> 每个事务会创建read-view，每行数据有多个版本

> 获取表中当前数据，再回滚事务期间的视图（使用undo log回滚），得到事务启动时的值

> 开启可重复读事务时，创建活跃事务数组和当前事务最大值+1(高水位)，低水位即是数组最小值。回滚时根据事务id和数组里的事务回滚得到值

> 读提交事务开启时，每次查询都会创建readview

MVCC读取的是快照读

当前读：更新时先读后写(select for update 或者select in share mode)

#### 事务

- 读未提交：事务没提交做的变更也能被看到
- 读提交：事务提交后，做的变更才能被看到
- 可重复读：事务执行过程中，看到的数据和事务启动前一致。即别的事务修改的数据看不到
- 串行化：写加写锁、读加读锁

##### 脏读

事务A对数据进行了修改，没有提交，事务B能查询到未提交的事务数据，并对数据进行了操作，如果A回滚，会导致数据不一致

##### 不可重读

事务A查询到数据后，其他事务修改后提交，事务A再次查询发现不一致

##### 幻读

事务在2个时刻读取范围的数据不一致(新插入了数据)。

幻读需要是当前读，因为快照读不会读其他事务的修改


#### 主从复制

##### 异步复制

事务提交后，主返回给客户端结果。
1、异步去同步bin-log给从(主的log-dump-thread线程)。
2、从节点I/O线程连接主节点接受数据，存放到repaly-log。
3、从节点Sql线程去读取repaly-log写入数据库


#### 内存结构

![innodb_内存架构](https://github.com/mirindalover/java-day/blob/master/%E4%B8%AD%E9%97%B4%E4%BB%B6/resource/mysql_innodb%E6%9E%B6%E6%9E%84.png)

1、Buffer Pool：缓冲池，是主内存中的一个区域，在InnoDB访问表和索引数据时会在其中进行高速缓存，大量减少磁盘IO操作，提升效率。

> 初始化时申请连续的内存空间，以页为单位来缓存数据
>
> 通过 free链表、flush链表来管理空闲页、脏页
>
> 改造Lru：分成了young区和old区，old存放预读的页(预读机制:mysql读取页时会吧相邻的页也读取出来)

2、Change Buffer：写缓冲区，避免每次增删改都进行IO操作，提升性能

> 如果页已经在内存了,不使用，直接更新到buffer pool对应的页中
>
> 唯一索引无法使用(唯一索引需要判断唯一性，必须加载页)。普通索引插入更新可以使用，后台定期刷新到磁盘

2.1 order Buffer、join Buffer

> order buffer用来排序:如果排序字段能在内存中完成排序则使用内存，否则使用磁盘创建排序文件

> join buffer：当被驱动表中链接字段没有索引时,整个过程在join buffer中。内存不够时,驱动表字段数据在内存中，分段加载被驱动表的数据来比较

3、Adaptive Hash Index：自适应哈希索引，使用索引关键字的前缀构建哈希索引，提升查询速度(不可人为控制)

> 索引直接指向数据页位置，避免回表

4、Log Buffer：日志缓冲区，保存要写入磁盘上的日志文件的数据，缓冲区的内容定期刷新到磁盘上。

> 批量写的思想
	
缺点就是会导致数据丢失。
innodb_flush_log_at_trx_commit 值0、1、2，分别表示:每秒写page cache并且刷新到磁盘、每次事务提交写page cache且刷新到磁盘、每次事务提交写page cache 每秒刷新到磁盘

5、double write buffer:与其他buffer不同，其他都是内存buffer，这个是内存/磁盘2层结构

> 内存buffer刷新到磁盘的时候，会进行页的写入(系统一页4k，bufer1页是16k。1个buffer页->4个系统页)

> 如果写buffer时断电会造成页数据不完整

由于redo log只能保证在页完整时，进行恢复。所以写时需要 使用另一块磁盘保证

> buffer写入时先写 double write buffer
> dwb的内存刷到dwb磁盘
> dwb内存再刷到数据磁盘上


#### 日志

> binlog：mysql的server层。归档日志。可以用来恢复数据。记录的是具体sql
>
> redo log：InnoDB的日志。数据更新时先写日志，等周期或者日志满再刷到磁盘，提供了crash-safe能力。即WAL(write-ahead loggin,预写日志)。其实是为了Buffer Pool问题引入的(InnoDB为了提升效率，把部分数据也映射，作为数据库的缓冲，会先写Buffer Pool，定期刷新到磁盘)
>
> undo Log：回滚日志。记录事务的回滚日志。是事务的原子性和隔离性的实现基础



