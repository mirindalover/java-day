### 数据库

#### 关系型数据库

事务的ACID：原子性、一致性、隔离性、持久性

###### 原子性

undolog：执行失败后使用undolog回滚

###### 隔离性

1、锁：表锁、行锁、next-key lock(行锁和间隙锁组合)

2、MVCC：版本控制。保证了mysql的高并发下的隔离

###### 持久性

1、引入redo log(WAL：预写式日志)。保证了数据不丢失
> a、mysql为了提供性能，添加了Buffer Pool，写磁盘时先修改内存，后台线程定时刷新到磁盘(刷脏),随机I/O
>
> b、事务先写redo log buffer，提交后刷新到redo log file中(顺序写)

2、结合binlog进行两阶段写。先写redo log的prepare，后写BinLog。再写redo log的commit

###### 一致性

以上来保证最后一致

缺点：
1、存储行记录，无法存储数据结构(List、Hash等。其实存储的都是字符串，然后再程序里面进行转换)：比如，想在list的头部添加记录。我们需要维护一个序号列保持list顺序，添加时需要获取所有的结果然后改变所有的序号
2、扩展Schema不方便(Schema是强约束)
3、大数据场景下I/O高。比如，只计算某一列的数据，也需要把所有的列都读出
4、全文搜索功能比较弱。like是进行表扫描匹配



#### 非关系型数据库

Nosql：not only sql

##### Redis

K-V类型。解决了关系型数据库不能存储数据结构的问题

###### 事务

1、MULTI开始事务、EXEC执行事务、DISCARD清除事务

事务时IC的。没有A、D

> 没有原子性是因为不能回滚，事务中某个命令失败不影响其他命令
>
> 没有持久性。Redis是内存操作，持久化可能没有开启


###### 库存扣减问题

1、redis的原子命令 DECRBY(减多少)

2、使用lua脚本进行扣减。逻辑先判断库存后再扣减

##### MongoDB

文档数据库(JSON为数据)。解决了mysql约束schema问题

另外优势：横向扩展，集群分片。可以支持大数据

###### 事务

##### HBase

列式存储


##### ES

倒排索引：根据关键词查询文档

类似Hive，也是分给每个节点去做检索









